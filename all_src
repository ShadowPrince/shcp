File ./project.clj
highlight: Unknown source file extension "clj".
(defproject shcp "0.1.0-SNAPSHOT"
  :description "command intepreter"
  :url "http://github.com/shadowprince/shcp"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.5.1"]
                 [clojure-lanterna "0.9.4"]]

  :main ^:skip-aot shcp.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}}

  :jvm-opts ["-Djava.library.path=java/bin"]
  :java-source-paths ["java/src"]

  :repl-options {:init (do 
                         ;; my dev stuff, dont ask about this
                         ;; anyway, I should use Stuart Sierra's reload
                         (in-ns 'user)
                         (load "autoload") 
                         (autoload/autoload-thread! "src/shcp") 
                         (println "Threaded autoloader engaged!")
                         (in-ns 'shcp.core)
                         (use 'clojure.repl)
                         (use 'clojure.pprint))}
  )
File ./src/shcp/ui/input.clj
highlight: Unknown source file extension "clj".
(ns shcp.ui.input)

File ./src/shcp/ui/core.clj
highlight: Unknown source file extension "clj".
(ns shcp.ui.core
  (:require [clojure.string :as str]
            [lanterna.screen :as s])) 

(defn prompt [st]
  (format (:prompt st) (-> st :env :dir)))
File ./src/shcp/core.clj
highlight: Unknown source file extension "clj".
(ns shcp.core
  (:gen-class)
  (:require [shcp.ui.core :as ui]
            [shcp.sh.jobs :as jobs]
            [shcp.sh.core :as sh]))

(defn state [prompt]
  {:prompt (or prompt "%s » ")

   :env {:dir "/home/sp"
         :vars {"path" "" "status" 0 "home" "/home/sp"}}
   :jobs (atom [])})

(defn plain-loop [-st]
  (print (ui/prompt -st))
  (flush)
  (if (:exit -st)
    nil
    (let [command (read-line)]
      (plain-loop 
        (sh/process-command -st command)))))


;; home - /home/sp
;; PATH - 0
;; status - 0
;; подстановка ENV

(defn -main [& args]
  (let [opts args
        prompt (nth opts (-> (take-while (partial not= "-p") opts) count inc))
        state (state prompt)]
    (jobs/handle-chld! state)
    (plain-loop state)))
File ./src/shcp/sh/internal.clj
highlight: Unknown source file extension "clj".
(ns shcp.sh.internal
  (:require [clojure.string :as str]
            [shcp.ui.core :as ui]
            [shcp.sh.util :refer :all]
            [shcp.sh.jobs :as jobs])
  (:import [org.sp.shcp.llapi LLAPI]))

(defn exit [st]
  (list (assoc st :exit true) {:exit 0}))

(defn cd [st arg]
  (let [dir (get-in st [:env :dir])
        newdir (cond 
              (.startsWith arg "/") arg
              (.startsWith arg "..") (str/join "/" (conj (butlast (str/split dir #"/")) ""))
              true (str dir "/" arg))]
    (if (= 0 (LLAPI/cd newdir))
      (list (-> st 
                (assoc-in [:env :dir] dir)) {:exit 0})  
      (list st {:exit -1 :err (format "No such dir: \"%s\"!\n" newdir)}))))

(defn wait [st & [strpid]]
  (if-let [{:keys [pid] :or [pid]} (jobs/-get st (Integer/parseInt strpid))]
    (list st {:exit (LLAPI/waitPid pid) :out (format "%s finished" pid)})
    (list st {:exit -1 :out (format "Pid or job \"%s\" not found!\n" strpid)})))

(defn jobs [st]
  (list st {:out (str (str/join "\n" (map-indexed #(format "#%d: pid %d" %1 (:pid %2)) @(:jobs st))) "\n")}))

(defn setenv [st k v]
  (list st (out-by-code (LLAPI/setEnv k v) "Set env failed with %d\n")))

(defn unsetenv [st k]
  (list st (out-by-code (LLAPI/unsetEnv k) "Unset env failed with %d\n")))

;; вывод всех
(defn getenv [st k]
  (list st {:out (format "variable %s:\n%s\n" k (LLAPI/getEnv k))}))

(defn setvar [st k v]
  (list (assoc-in st [:env :vars k] v) {}))

(defn unsetvar [st k]
  (list (update-in st [:env :vars] dissoc k) {}))

(defn getvar [st k]
  (list st {:out (str (get-in st [:env :vars k]) "\n") :exit 0}))

(defn pwd [st]
  (list st {:out (str (get-in st [:env :dir]) "\n")}))

(defn echo [st & args]
  (list st {:out (str (str/join " " args) "\n")}))

(defn internal? [cmd]
  (let [publics (ns-publics 'shcp.sh.internal)]
    (->> (str/split cmd #" ") first symbol publics)))

(defn internal [st cmd]
  (let [[cmd & args] (str/split cmd #" ")]
    (try
      (apply (->> cmd symbol (ns-resolve 'shcp.sh.internal)) st args)
      (catch Exception e (list st {:exit 1 :out (str "spsh: " e "\n")})))))
File ./src/shcp/sh/util.clj
highlight: Unknown source file extension "clj".
(ns shcp.sh.util)

(defn out-by-code [code error]
  (if (zero? code)
    {:exit 0}
    {:err (format error code) :exit code}))
File ./src/shcp/sh/core.clj
highlight: Unknown source file extension "clj".
(ns shcp.sh.core
  (:require [shcp.sh.exec :as e]
            [shcp.sh.internal :as i]
            [shcp.ui.core :as ui]
            [shcp.ui.input :as in]
            [shcp.sh.args :as args]
            [clojure.string :as str]))

(defn internal-out! [out]
  (if-let [o (:out out)]
    (print o))
  (if-let [o (:err out)]
    (print o)))

(defn process-command 
  "Process command if available from on state ~st"
  [st cmd]
  (if (empty? cmd)
    st
    (let [cmd (args/sub-vars st cmd)
          [st o] (if (i/internal? cmd) (i/internal st cmd) (e/execute st cmd))]
      (internal-out! o)
      (assoc-in st [:env :vars :status] (:exit o)))))

File ./src/shcp/sh/args.clj
highlight: Unknown source file extension "clj".
(ns shcp.sh.args
  (:require [clojure.string :as str]))

(defn parse-args [line in-quotes]
  (let [breaking-characters (cond 
                              in-quotes #{\"}
                              :else #{\space \\ \"})
        [index, character] (loop [[ch & rest-line] line]
                             (cond
                               (nil? ch) [(count line) , nil]
                               (breaking-characters ch) [(- (count line) (count rest-line)) (breaking-characters ch)]
                               :else (recur rest-line)))
        from 0
        [cto, lto, in-quotes] (case character
                                \space [(dec index) index false]
                                \\ [index (-> index inc) false]
                                \" [(dec index) index (not in-quotes)]
                                nil [index nil nil])
        arg (case character
              \\ (str (.substring line 0 (dec index)) (.substring line index lto))
              (.substring line from cto))]
    (cond 
      (nil? lto) []
      (empty? arg) (parse-args (.substring line lto) in-quotes)
      :else (cons arg (parse-args (.substring line lto) in-quotes)))))

(defn sub-vars [st line]
  (reduce (fn [line [k v]]
            (str/replace line (str " $" k " ") (str " " v " ")))
          (str line " ") 
          (get-in st [:env :vars])))
File ./src/shcp/sh/exec.clj
highlight: Unknown source file extension "clj".
(ns shcp.sh.exec
  (:import (java.io File IOException)
           (org.sp.shcp.llapi LLAPI))
  (:require [clojure.java.shell :as sh]
            [clojure.java.io :as io]
            [clojure.string :as str]
            [shcp.sh.util :refer :all]
            [shcp.sh.args :as args]
            [shcp.sh.jobs :as jobs]))

(defn find-exec [executable]
  (let [PATH (str/split (LLAPI/getEnv "PATH") #"\:")]
    (loop [[p & r] PATH]
      (cond
        (nil? p) nil
        (.exists (io/file (str p "/" executable))) (str p "/" executable)
        :else (recur r)))))

(defn exec [st cmd args]
  (list st (out-by-code (LLAPI/exec cmd (into-array args)) "Exec failed with code %d\n")))

(defn exec-background [st cmd args]
  (let [pid (LLAPI/execBackground cmd  (into-array args))
        job (jobs/push! st pid)]
    (list st {:exit 0 :out (format "%d in background, job #%d\n" pid job)})))

(defn execute [st cmd]
  (let [[cmd, & args] (args/parse-args cmd false)
        [args, background] (if (= (last args) "&") [(butlast args) true] [args false])

        args (cons cmd args) 
        cmd (find-exec cmd)]
    (try 
      (cond
        (nil? cmd) (list st {:exit 1 :out "spsh: command not found\n"})
        background (exec-background st cmd args)
        :else (exec st cmd args))
      (catch java.io.IOException e (list st {:exit -10 :err (str e)}))))) 
File ./src/shcp/sh/jobs.clj
highlight: Unknown source file extension "clj".
(ns shcp.sh.jobs
  (:import [sun.misc Signal SignalHandler]
           [org.sp.shcp.llapi LLAPI]))

(defn storage []
  (atom []))

(defn -get [st i]
  (if (> (count @(:jobs st)) i)
    (nth @(:jobs st) i)
    (let [f (filter #(= (:pid %) i) @(:jobs st))]
      (if (empty? f)
        nil
        (first f)))))

(defn push! [st pid]
  (swap! (:jobs st) conj {:pid pid})
  (dec (count @(:jobs st))))

(defn handle-chld! [st]
  (Signal/handle (Signal. "CHLD") 
                 (proxy [SignalHandler] []
                   (handle [sig] 
                     (loop [code (LLAPI/checkPid -1)]
                       (cond
                         (neg? code) nil
                         (zero? code) (recur (LLAPI/checkPid -1))
                         :else (do
                                 (swap! (:jobs st) #(remove (fn [j] (= (:pid j) code)) %1))
                                 (println (format "Process %d finished!\n" code))
                                 (recur (LLAPI/checkPid -1))))))))
  (Signal/handle (Signal. "INT") 
                 (proxy [SignalHandler] []
                   (handle [sig] 
                     nil))))

File ./src/autoload.clj
highlight: Unknown source file extension "clj".
(ns autoload
  (:import java.io.File)
  (:use [clojure.string :only (split)]))

(defn get-files-mdates [d]
  (let [entries (.listFiles d)
        dirs (filter #(.isDirectory %) entries)
        files (reduce 
                #(assoc %1 (.getAbsolutePath %2) (.lastModified %2)) 
                {} 
                (->> entries
                  (filter #(.isFile %))
                  (filter #(-> % (.getName) (.endsWith "clj")))))]
    (merge files (mapcat get-files-mdates dirs))))

(defn autoload!
  ([path] (autoload! path false []))
  ([path verbose] (autoload! path verbose []))
  ([path verbose coll]
   (let [mdates (get-files-mdates (File. path))]
     (doseq [f mdates]
       (let [k (key f)
             oldts (get coll k)
             newts (val f)]
         (if (not= oldts newts)
           (do
             (if verbose
               (print (str "File " k " modified, loading... ")))
             (load-file k)
             (if verbose
               (println "ok."))))))
     mdates)))

(def update-omdates (atom {}))

(defn autoload-update! [path]
  (reset! update-omdates (autoload! path true @update-omdates)))

(defn autoload-exception-handle! [path e]
  (let [mdates (get-files-mdates (File. path))]
    (.printStackTrace e)
    mdates))

(defn autoload-thread-fn [path verbose]
  (let [omdates (atom {})]
    (fn [] 
      (while true
        (try
          (reset! omdates (autoload! path verbose @omdates))
          (catch Exception e (reset! omdates (autoload-exception-handle! path e))))
        (Thread/sleep 500)))))

(def thread-instance (atom nil))

(defn autoload-thread!
  ([path] (autoload-thread! path false))
  ([path verbose] (autoload-thread! path verbose thread-instance))
  ([path verbose & [thread-atom]]
   (if (and (instance? Thread @thread-atom) (.running @thread-atom))
     (prn "Thread " @thread-atom " in atom " thread-atom " is already running!")
     (.start (reset! thread-atom (Thread. (autoload-thread-fn path verbose)))))))


(defn autoload-thread-interrupt! 
  ([] (autoload-thread-interrupt! thread-instance))
  ([thread-atom] (.interrupt @thread-atom)))


;; 
;; PROJECT ZONE
;; 


File ./java/src/org/sp/shcp/llapi/LLAPI.java
package org.sp.shcp.llapi;

public class LLAPI {
    static {
        loadLibrary();
    }

    public static void loadLibrary() {
        System.loadLibrary("llapi");
    }

    native public static int exec(String cmd, String[] args);
    native public static int execBackground(String cmd, String[] args);

    native public static int waitPid(int pid);
    native public static int checkPid(int pid);

    native public static int cd(String path);
    
    native public static int setEnv(String key, String value);
    native public static int unsetEnv(String key);
    native public static String getEnv(String key);
}
File ./java/src/Test.java
import org.sp.shcp.llapi.LLAPI;
import sun.misc.Signal;
import sun.misc.SignalHandler;

public class Test {
    public static void slp(long s) {
        try {
            Thread.sleep(s);
        } catch (Exception e) {}
    }

    public static void main(String[] args) {
        /*
        Signal.handle(new Signal("INT"), new SignalHandler() {
            public void handle(Signal sig) {
                System.out.println("INT");
            }
        });

        */
        int pid = LLAPI.execBackground("/usr/bin/sleep", new String[] {"sleep", "2"});
        System.out.println("pid - " + pid);
        while (true)  {
            System.out.println(LLAPI.checkPid(-1));
            slp(1000);
        }

    }
}
File ./java/bin/main.c
#include "org_sp_shcp_llapi_LLAPI.c"
 main(){test();}
File ./java/bin/org_sp_shcp_llapi_LLAPI.c
#include "org_sp_shcp_llapi_LLAPI.h"
#include <iostream>
#include "stdlib.h"
#include "unistd.h"
#include "string.h"
#include "sys/wait.h"
#include <vector>

extern char **environ;

int spawnv(const char *cmd, char *const args[]) {
    int process = 0;
    process = fork();
    if (process == 0) {
        execvpe(cmd, args, environ);
        exit(1);
    } else {
        int status;
        waitpid(process, &status, 0);
        return status;
    }
}

int spawnv_background(const char *cmd, char *const args[]) {
    int process = 0;
    if (process = fork()) {
        return process;
    } else {
        execvpe(cmd, args, environ);
        exit(1);
    }
}

JNIEXPORT jint JNICALL Java_org_sp_shcp_llapi_LLAPI_exec (JNIEnv *env, jclass cls, jstring str, jobjectArray stringArray) {
    const char *path = env->GetStringUTFChars(str, JNI_FALSE);

    int length = env->GetArrayLength(stringArray);
    char **args = (char**) malloc(sizeof(char*) * length);

    for (int i = 0; i < length; ++i) {
        jstring jstr = (jstring) env->GetObjectArrayElement(stringArray, i);
        const char* cpp_string = env->GetStringUTFChars(jstr, 0);

        args[i] = (char*) malloc(strlen(cpp_string) + 1);
        strcpy(args[i], cpp_string);

        env->ReleaseStringUTFChars(jstr, cpp_string);
        env->DeleteLocalRef(jstr);
    }

    args[length] = (char*) 0;

    int result = spawnv(path, args);
    env->ReleaseStringUTFChars(str, path);
    return (jint) result;
}

JNIEXPORT jint JNICALL Java_org_sp_shcp_llapi_LLAPI_execBackground (JNIEnv *env, jclass cls, jstring str, jobjectArray stringArray) {
    const char *path = env->GetStringUTFChars(str, JNI_FALSE);

    int length = env->GetArrayLength(stringArray);
    char **args = (char**) malloc(sizeof(char*) * length);

    for (int i = 0; i < length; ++i) {
        jstring jstr = (jstring) env->GetObjectArrayElement(stringArray, i);
        const char* cpp_string = env->GetStringUTFChars(jstr, 0);

        args[i] = (char*) malloc(strlen(cpp_string) + 1);
        strcpy(args[i], cpp_string);

        env->ReleaseStringUTFChars(jstr, cpp_string);
        env->DeleteLocalRef(jstr);
    }

    args[length] = (char*) 0;

    int result = spawnv_background(path, args);
    env->ReleaseStringUTFChars(str, path);
    return (jint) result;
}

JNIEXPORT jint JNICALL Java_org_sp_shcp_llapi_LLAPI_setEnv (JNIEnv *env, jclass cls, jstring jkey, jstring jvalue) {
    const char *key = env->GetStringUTFChars(jkey, JNI_FALSE);
    const char *value = env->GetStringUTFChars(jvalue, JNI_FALSE);

    int result = setenv(key, value, 1);

    env->ReleaseStringUTFChars(jkey, key);
    env->ReleaseStringUTFChars(jvalue, value);
    return result;
}

JNIEXPORT jint JNICALL Java_org_sp_shcp_llapi_LLAPI_unsetEnv (JNIEnv *env, jclass cls, jstring jkey) {
    const char *key = env->GetStringUTFChars(jkey, JNI_FALSE);

    int result = unsetenv(key);

    env->ReleaseStringUTFChars(jkey, key);
    return result;
}

JNIEXPORT jstring JNICALL Java_org_sp_shcp_llapi_LLAPI_getEnv (JNIEnv *env, jclass cls, jstring jkey) {
    const char *key = env->GetStringUTFChars(jkey, JNI_FALSE);

    const char *value = getenv(key);

    env->ReleaseStringUTFChars(jkey, key);

    jstring result = env->NewStringUTF(value);
    return result;
}

JNIEXPORT jint JNICALL Java_org_sp_shcp_llapi_LLAPI_cd (JNIEnv *env, jclass cls, jstring str) {
    const char *path = env->GetStringUTFChars(str, JNI_FALSE);
    int result = chdir(path);
    env->ReleaseStringUTFChars(str, path);
    return result;
}

JNIEXPORT jint JNICALL Java_org_sp_shcp_llapi_LLAPI_waitPid (JNIEnv *env, jclass cls, jint pid) {
    int status;
    return (jint) waitpid(pid, &status, 0);
    //return (jint) status;
}

JNIEXPORT jint JNICALL Java_org_sp_shcp_llapi_LLAPI_checkPid (JNIEnv *env, jclass cls, jint pid) {
    int status;
    return (jint) waitpid(pid, &status, WNOHANG);
    //return (jint) status;
}
